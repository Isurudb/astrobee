// Auto-generated. Do not edit!

// (in-package ff_msgs.msg)


"use strict";

const _serializer = _ros_msg_utils.Serialize;
const _arraySerializer = _serializer.Array;
const _deserializer = _ros_msg_utils.Deserialize;
const _arrayDeserializer = _deserializer.Array;
const _finder = _ros_msg_utils.Find;
const _getByteLength = _ros_msg_utils.getByteLength;
let FlightMode = require('./FlightMode.js');
let ControlState = require('./ControlState.js');

//-----------------------------------------------------------

class MotionResult {
  constructor(initObj={}) {
    if (initObj === null) {
      // initObj === null is a special case for deserialization where we don't initialize fields
      this.response = null;
      this.fsm_result = null;
      this.flight_mode = null;
      this.segment = null;
    }
    else {
      if (initObj.hasOwnProperty('response')) {
        this.response = initObj.response
      }
      else {
        this.response = 0;
      }
      if (initObj.hasOwnProperty('fsm_result')) {
        this.fsm_result = initObj.fsm_result
      }
      else {
        this.fsm_result = '';
      }
      if (initObj.hasOwnProperty('flight_mode')) {
        this.flight_mode = initObj.flight_mode
      }
      else {
        this.flight_mode = new FlightMode();
      }
      if (initObj.hasOwnProperty('segment')) {
        this.segment = initObj.segment
      }
      else {
        this.segment = [];
      }
    }
  }

  static serialize(obj, buffer, bufferOffset) {
    // Serializes a message object of type MotionResult
    // Serialize message field [response]
    bufferOffset = _serializer.int32(obj.response, buffer, bufferOffset);
    // Serialize message field [fsm_result]
    bufferOffset = _serializer.string(obj.fsm_result, buffer, bufferOffset);
    // Serialize message field [flight_mode]
    bufferOffset = FlightMode.serialize(obj.flight_mode, buffer, bufferOffset);
    // Serialize message field [segment]
    // Serialize the length for message field [segment]
    bufferOffset = _serializer.uint32(obj.segment.length, buffer, bufferOffset);
    obj.segment.forEach((val) => {
      bufferOffset = ControlState.serialize(val, buffer, bufferOffset);
    });
    return bufferOffset;
  }

  static deserialize(buffer, bufferOffset=[0]) {
    //deserializes a message object of type MotionResult
    let len;
    let data = new MotionResult(null);
    // Deserialize message field [response]
    data.response = _deserializer.int32(buffer, bufferOffset);
    // Deserialize message field [fsm_result]
    data.fsm_result = _deserializer.string(buffer, bufferOffset);
    // Deserialize message field [flight_mode]
    data.flight_mode = FlightMode.deserialize(buffer, bufferOffset);
    // Deserialize message field [segment]
    // Deserialize array length for message field [segment]
    len = _deserializer.uint32(buffer, bufferOffset);
    data.segment = new Array(len);
    for (let i = 0; i < len; ++i) {
      data.segment[i] = ControlState.deserialize(buffer, bufferOffset)
    }
    return data;
  }

  static getMessageSize(object) {
    let length = 0;
    length += object.fsm_result.length;
    length += FlightMode.getMessageSize(object.flight_mode);
    length += 160 * object.segment.length;
    return length + 12;
  }

  static datatype() {
    // Returns string type for a message object
    return 'ff_msgs/MotionResult';
  }

  static md5sum() {
    //Returns md5sum for a message object
    return 'd9085ddc2b12a9c56a85552d7ec1a05e';
  }

  static messageDefinition() {
    // Returns full string definition for message
    return `
    # ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======
    
    # Motion result
    int32 response                            # Motion action response
    int32 ALREADY_THERE                         =   2  # MOVE: We are already at the location
    int32 SUCCESS                               =   1  # ALL: Motion succeeded
    int32 PREEMPTED                             =   0  # ALL: Motion preempted by thirdparty
    int32 PLAN_FAILED                           =  -1  # MOVE/EXEC: Plan/bootstrap failed
    int32 VALIDATE_FAILED                       =  -2  # MOVE/EXEC: No comms with mapper
    int32 PMC_FAILED                            =  -3  # MOVE/EXEC: PMC failed
    int32 CONTROL_FAILED                        =  -4  # ALL: Control failed
    int32 OBSTACLE_DETECTED                     =  -5  # ALL: Obstacle / replan disabled
    int32 REPLAN_NOT_ENOUGH_TIME                =  -6  # MOVE/EXEC: Not enough time to replan
    int32 REPLAN_FAILED                         =  -7  # MOVE/EXEC: Replanning failed
    int32 REVALIDATE_FAILED                     =  -8  # MOVE/EXEC: Revalidating failed
    int32 NOT_IN_WAITING_MODE                   =  -9  # ALL: Internal failure
    int32 INVALID_FLIGHT_MODE                   =  -10 # ALL: No flight mode specified
    int32 UNEXPECTED_EMPTY_SEGMENT              =  -11 # EXEC: Segment empty
    int32 COULD_NOT_RESAMPLE                    =  -12 # EXEC: Could not resample segment
    int32 UNEXPECTED_EMPTY_STATES               =  -13 # MOVE: State vector empty
    int32 INVALID_COMMAND                       =  -14 # Command rejected
    int32 CANNOT_QUERY_ROBOT_POSE               =  -15 # TF2 failed to find the current pose
    int32 NOT_ON_FIRST_POSE                     =  -16 # EXEC: Not on first pose of exec
    int32 BAD_DESIRED_VELOCITY                  =  -17 # Requested vel too high
    int32 BAD_DESIRED_ACCELERATION              =  -18 # Requested accel too high
    int32 BAD_DESIRED_OMEGA                     =  -19 # Requested omega too high
    int32 BAD_DESIRED_ALPHA                     =  -20 # Requested alpha too high
    int32 BAD_DESIRED_RATE                      =  -21 # Requested rate too low
    int32 TOLERANCE_VIOLATION_POSITION_ENDPOINT =  -22 # Position tolerance violated
    int32 TOLERANCE_VIOLATION_POSITION          =  -23 # Position tolerance violated
    int32 TOLERANCE_VIOLATION_ATTITUDE          =  -24 # Attitude tolerance violated
    int32 TOLERANCE_VIOLATION_VELOCITY          =  -25 # Velocity tolerance violated
    int32 TOLERANCE_VIOLATION_OMEGA             =  -26 # Omega tolerance violated
    int32 VIOLATES_RESAMPLING                   =  -27 # Validation: could not resample@10Hz
    int32 VIOLATES_KEEP_OUT                     =  -28 # Validation: Keep out violation
    int32 VIOLATES_KEEP_IN                      =  -29 # Validation: Keep in violation
    int32 VIOLATES_MINIMUM_FREQUENCY            =  -30 # Validation: Sample frequency too low
    int32 VIOLATES_STATIONARY_ENDPOINT          =  -31 # Validation: Last setpoint not static
    int32 VIOLATES_FIRST_IN_PAST                =  -32 # Validation: First timestamp in past
    int32 VIOLATES_MINIMUM_SETPOINTS            =  -33 # Validation: Not enough setpoints
    int32 VIOLATES_HARD_LIMIT_VEL               =  -34 # Validation: Velocity too high
    int32 VIOLATES_HARD_LIMIT_ACCEL             =  -35 # Validation: Acceleration too high
    int32 VIOLATES_HARD_LIMIT_OMEGA             =  -36 # Validation: Omega too high
    int32 VIOLATES_HARD_LIMIT_ALPHA             =  -37 # Validation: Alpha too high
    int32 CANCELLED                             =  -38 # ALL: Motion cancelled by callee
    int32 INVALID_REFERENCE_FRAME               =  -39 # ALL: Unknown reference frame
    
    # Human readable FSM result for debugging
    string fsm_result
    
    # The flight mode parameters used
    ff_msgs/FlightMode flight_mode
    
    # The final segment that was flown
    ff_msgs/ControlState[] segment
    
    
    ================================================================================
    MSG: ff_msgs/FlightMode
    # Copyright (c) 2017, United States Government, as represented by the
    # Administrator of the National Aeronautics and Space Administration.
    #
    # All rights reserved.
    #
    # The Astrobee platform is licensed under the Apache License, Version 2.0
    # (the "License"); you may not use this file except in compliance with the
    # License. You may obtain a copy of the License at
    #
    #     http://www.apache.org/licenses/LICENSE-2.0
    #
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
    # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
    # License for the specific language governing permissions and limitations
    # under the License.
    #
    # This message captures all information in a flight mode
    
    Header header                     # Metadata
    
    string name                       # Name of the flight mode
    
    bool control_enabled              # Is control enabled?
    
    # Tolerances (all in SI units)
    float32 tolerance_pos_endpoint    # Endpoint position tolerance in m
    float32 tolerance_pos             # Position tolerance in m
    float32 tolerance_vel             # Velocity tolerance in m/s
    float32 tolerance_att             # Attitude tolerance in rads
    float32 tolerance_omega           # Angular acceleration tolerance in rad/s
    float32 tolerance_time            # Acceptable lag betwee TX and RX of control
    
    # Controller gains
    geometry_msgs/Vector3 att_kp      # Positional proportional constant
    geometry_msgs/Vector3 att_ki      # Positional integrative constant
    geometry_msgs/Vector3 omega_kd    # Attidue derivative constant
    geometry_msgs/Vector3 pos_kp      # Positional proportional contant
    geometry_msgs/Vector3 pos_ki      # Positional integrative constant
    geometry_msgs/Vector3 vel_kd      # Positional derivative constant
    
    # Hard limit on planning
    float32 hard_limit_vel            # Position tolerance in m/s
    float32 hard_limit_accel          # Position tolerance in m/s^2
    float32 hard_limit_omega          # Position tolerance in rads/s
    float32 hard_limit_alpha          # Position tolerance in rads/s^2
    
    # Impeller speed
    uint8 speed                       # Current speed gain
    uint8 SPEED_MIN        = 0        # Min acceptable gain
    uint8 SPEED_OFF        = 0        # Blowers off
    uint8 SPEED_QUIET      = 1        # Quiet mode
    uint8 SPEED_NOMINAL    = 2        # Nomainal mode
    uint8 SPEED_AGGRESSIVE = 3        # Aggressive mode
    uint8 SPEED_MAX        = 3        # Max acceptable gain
    
    ================================================================================
    MSG: std_msgs/Header
    # Standard metadata for higher-level stamped data types.
    # This is generally used to communicate timestamped data 
    # in a particular coordinate frame.
    # 
    # sequence ID: consecutively increasing ID 
    uint32 seq
    #Two-integer timestamp that is expressed as:
    # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    # time-handling sugar is provided by the client library
    time stamp
    #Frame this data is associated with
    # 0: no frame
    # 1: global frame
    string frame_id
    
    ================================================================================
    MSG: geometry_msgs/Vector3
    # This represents a vector in free space. 
    # It is only meant to represent a direction. Therefore, it does not
    # make sense to apply a translation to it (e.g., when applying a 
    # generic rigid transformation to a Vector3, tf2 will only apply the
    # rotation). If you want your data to be translatable too, use the
    # geometry_msgs/Point message instead.
    
    float64 x
    float64 y
    float64 z
    ================================================================================
    MSG: ff_msgs/ControlState
    # Copyright (c) 2017, United States Government, as represented by the
    # Administrator of the National Aeronautics and Space Administration.
    # 
    # All rights reserved.
    # 
    # The Astrobee platform is licensed under the Apache License, Version 2.0
    # (the "License"); you may not use this file except in compliance with the
    # License. You may obtain a copy of the License at
    # 
    #     http://www.apache.org/licenses/LICENSE-2.0
    # 
    # Unless required by applicable law or agreed to in writing, software
    # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
    # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
    # License for the specific language governing permissions and limitations
    # under the License.
    #
    # Full state vector containing Time, Pose, Vel, and Accel
    # 
    # when {time}
    # flight_mode {string} - disctates, gains, tolerances, etc.
    # pose {Point position, Quaternion orientation}
    # twist {Vector3 linear, Vector3 angular}
    # accel {Vector3 linear, Vector3 angular}
    
    time when
    geometry_msgs/Pose pose
    geometry_msgs/Twist twist
    geometry_msgs/Twist accel
    
    ================================================================================
    MSG: geometry_msgs/Pose
    # A representation of pose in free space, composed of position and orientation. 
    Point position
    Quaternion orientation
    
    ================================================================================
    MSG: geometry_msgs/Point
    # This contains the position of a point in free space
    float64 x
    float64 y
    float64 z
    
    ================================================================================
    MSG: geometry_msgs/Quaternion
    # This represents an orientation in free space in quaternion form.
    
    float64 x
    float64 y
    float64 z
    float64 w
    
    ================================================================================
    MSG: geometry_msgs/Twist
    # This expresses velocity in free space broken into its linear and angular parts.
    Vector3  linear
    Vector3  angular
    
    `;
  }

  static Resolve(msg) {
    // deep-construct a valid message object instance of whatever was passed in
    if (typeof msg !== 'object' || msg === null) {
      msg = {};
    }
    const resolved = new MotionResult(null);
    if (msg.response !== undefined) {
      resolved.response = msg.response;
    }
    else {
      resolved.response = 0
    }

    if (msg.fsm_result !== undefined) {
      resolved.fsm_result = msg.fsm_result;
    }
    else {
      resolved.fsm_result = ''
    }

    if (msg.flight_mode !== undefined) {
      resolved.flight_mode = FlightMode.Resolve(msg.flight_mode)
    }
    else {
      resolved.flight_mode = new FlightMode()
    }

    if (msg.segment !== undefined) {
      resolved.segment = new Array(msg.segment.length);
      for (let i = 0; i < resolved.segment.length; ++i) {
        resolved.segment[i] = ControlState.Resolve(msg.segment[i]);
      }
    }
    else {
      resolved.segment = []
    }

    return resolved;
    }
};

// Constants for message
MotionResult.Constants = {
  ALREADY_THERE: 2,
  SUCCESS: 1,
  PREEMPTED: 0,
  PLAN_FAILED: -1,
  VALIDATE_FAILED: -2,
  PMC_FAILED: -3,
  CONTROL_FAILED: -4,
  OBSTACLE_DETECTED: -5,
  REPLAN_NOT_ENOUGH_TIME: -6,
  REPLAN_FAILED: -7,
  REVALIDATE_FAILED: -8,
  NOT_IN_WAITING_MODE: -9,
  INVALID_FLIGHT_MODE: -10,
  UNEXPECTED_EMPTY_SEGMENT: -11,
  COULD_NOT_RESAMPLE: -12,
  UNEXPECTED_EMPTY_STATES: -13,
  INVALID_COMMAND: -14,
  CANNOT_QUERY_ROBOT_POSE: -15,
  NOT_ON_FIRST_POSE: -16,
  BAD_DESIRED_VELOCITY: -17,
  BAD_DESIRED_ACCELERATION: -18,
  BAD_DESIRED_OMEGA: -19,
  BAD_DESIRED_ALPHA: -20,
  BAD_DESIRED_RATE: -21,
  TOLERANCE_VIOLATION_POSITION_ENDPOINT: -22,
  TOLERANCE_VIOLATION_POSITION: -23,
  TOLERANCE_VIOLATION_ATTITUDE: -24,
  TOLERANCE_VIOLATION_VELOCITY: -25,
  TOLERANCE_VIOLATION_OMEGA: -26,
  VIOLATES_RESAMPLING: -27,
  VIOLATES_KEEP_OUT: -28,
  VIOLATES_KEEP_IN: -29,
  VIOLATES_MINIMUM_FREQUENCY: -30,
  VIOLATES_STATIONARY_ENDPOINT: -31,
  VIOLATES_FIRST_IN_PAST: -32,
  VIOLATES_MINIMUM_SETPOINTS: -33,
  VIOLATES_HARD_LIMIT_VEL: -34,
  VIOLATES_HARD_LIMIT_ACCEL: -35,
  VIOLATES_HARD_LIMIT_OMEGA: -36,
  VIOLATES_HARD_LIMIT_ALPHA: -37,
  CANCELLED: -38,
  INVALID_REFERENCE_FRAME: -39,
}

module.exports = MotionResult;
